# dojo/_base/lang.hitch 深度理解标签（空格分隔）： dojo---## 应用案例节选dojo widget中的一个函数```.javascript/** * 添加节点，并为每个节点绑定点击事件 * @private */_addNode:function () {    arrayUtil.forEach(this.data,lang.hitch(this,function (data,i) {    var tr=domConstruct.create('tr');    var td0=domConstruct.create('td',{innerHTML:i+1});    var td1=domConstruct.create('td',{innerHTML:data.attributes.OBJECTID});    var td2=domConstruct.create('td',{innerHTML:data.attributes.入库时间});    domConstruct.place(td0,tr);    domConstruct.place(td1,tr);    domConstruct.place(td2,tr);    on(tr,'click',lang.hitch(this,this._trClick,tr));  //传入tr    domConstruct.place(tr,this.dataset);    }));},```dojo 官方demo```.javascript var foo = {bar:function (a,b,c) {            console.log(a,b,c);        }} //1 lang.hitch(foo,'bar')();  //result undefined undefined undefined //通过函数名运行 //2 lang.hitch(foo, myFunction); //返回一个thisw为foo的myFunction //3 var foo = { bar: function(a, b, c){ console.log(a, b, c); } }; var fn = lang.hitch(foo, "bar", 1, 2); fn(3); // logs "1, 2, 3" //返回的fn的调用函数为bar并且arg 1 2 分别绑定1 2 //4 var foo = { bar: 2 }; lang.hitch(foo, function(){ this.bar = 10; })(); //直接更改到foo```涉及原理this call## this 1.作为对象方法调用 this.指向该对象本身 2.作为普通函数调用 this 指向全局变量 3.构造函数中调用 this 指向构造函数返回的对象 4.Function.prototype.call/apply调用 动态改变传入函数的this demo 普通函数与对象方法```.javascript  var obj1={    name:'sven',    getName:function(){        var that = this;       //解决普通函数指向全局的方案        function func(){            console.log(that)  //obj1            console.log(this)  //window        }();        return this.name;  //sven        }    }; console.log(obj1.getName());``` ```.javascript //call&applyvar func = function(a,b,c){    console.log(a,b,c);    }    func.call(null,1,2,3)     func.apply(null,[1,2,3])    //result 1 2 3```## 自行实现hitch函数```.javascript var myFunction = function (a,b,c) {            console.log(this);   //foo            console.log(a,b,c);  //1,2,3        } //Funciton.prototype.bind; myFunction.bind(foo,1,2,3)(); lang.hitch(foo,myFunction,1,2,3)()```现在已经可以达到几乎相同的效果了,```.javascirptvar myhitch=function(){        var context=[].shift.call(arguments),     //获取第一个值作为函数        that = [].shift.call(arguments),     //获取第2个值作为即将绑定的作用域        args = [].slice.call(arguments);        return function () {                return context.apply(that,[].concat.call(args,[].slice.call(arguments)));            }    }myhitch(foo,myFunction,1,2,3)()``` 